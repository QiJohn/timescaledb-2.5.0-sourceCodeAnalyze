PostgreSQL支持一个强大的 规则系统用于支持视图说明和模糊不清的视图更新。本来PostgreSQL规则系统由两种实现组成：
    第一种利用行级处理工作，并且被实现于执行器深层。当单独一行被访问时规则系统被调用。这种实现在1995年被移除，那时最后一个Berkeley Postgres项目的官方发布被转换为Postgres95。
    第二种规则系统的实现是一种称为查询重写的技术。重写系统是一个存在于分析器阶段和规划器/优化器之间的模块。这种技术也被实现了。
    规则系统更准确得说查询重写规则系统。从使用上来说，规则系统上得一些功能也可以通过函数和触发器来实现，但规则系统和触发器是完全不同。它是把用户发送过来得SQL命令在执行前通过内部得规则定义改编成另一个SQL命令后再执行新SQL命令得方式。
    规则从属于表或者视图的。如果一张表属于一个用户，则这张表上的所有规则都属于这个用户的。



————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
===========创建规则的语法：
    CREATE [ OR REPLACE ] RULE name AS ON event
        TO table_name [ WHERE condition ]
        DO [ ALSO | INSTEAD ] { NOTHING | command | ( command ; command ... ) }

语法中的“event”可以取下列值：
    （1）SELECT：上述介绍过的SELECT规则，当SQL的查询计划中存在查询表的操作时会重写查询计划。
    （2）INSERT：当SQL的查询计划中存在向表中插入数据的操作时会重写查询计划。
    （3）UPDATE：当SQL的查询计划中存在向表中更新数据的操作时会重写查询计划。
    （4）DELETE：当SQL的查询计划中存在将表中数据删除的操作时会重写查询计划。
    而更新规则就包括了INSERT、UPDATE、DELETE。

语法中的“ALSO”、“INSTEAD”说明如下：
    （1）ALSO：除了执行原本操作外，还执行一些附加操作，这些附加操作由后面的 “command” 指定。
    （2）INSTEAD：用后面的 “command” 操作代替原操作。
    
语法中的“NOTHING”表示什么都不执行。

针对SELECT命令的规则，其“RULE”的名称只能为“_RETURN”，同时后续动作只能为以“INSTEAD”开始的另一个SELECT语句，即： 
    CREATE [ OR REPLACE ] RULE “_RETURN” AS ON SELECT
        TO table_name [ WHERE condition ]
        DO  INSTEAD  { select语句 }
        
postgresql中创建视图是通过SELECT规则来实现的，创建视图的命令如“CREATE VIEW myview AS SELECT * FROM mytable;”，其等价的SQL命令为“ CREATE VIEW myview (same column list as mytable);     CREATE RULE "_RETURN" AS ON SELECT TO myview DO INSTEAD SELECT * FROM mytable; ”
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————





————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
=============规则系统的权限规定：
    因规则而使用的关系要对定义规则的属主进行权限检查，而不是检查执行规则的用户，这意味着，用户只需要对查询中明确指定的表、视图拥有权限就可以执行操作。即在规则系统中检测权限时，是对规则从属于的表、视图的属主进行权限检查，而不是执行规则的用户。
    例如：用户“user01”创建查询表“mytab”的视图“myview2”，表“mytab”的属主为用户“osdba”，用户“user01”对表“mytab”没有查询权限。
    操作：当以用户“osdba”登录，查询视图“myview2”失败。
    原因分析：执行用户“osdba”涉及到的规则属主为用户“user01”，而该用户无法访问表“mytab”，即使规则无法访问表“mytab”

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————





————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
=============规则和命令状态：
    PostgreSQL服务器为它收到的每个命令返回一个命令状态字符串，例如INSERT 149592 1。规则会改变这些命令影响的行数，没有涉及规则时这很简单，但是查询被规则重写时会发生什么呢？
    规则对命令状态的影响如下：
        如果没有查询的无条件INSTEAD规则，那么原始给出的查询将会被执行，并且它的命令状态将像平常一样被返回（但是请注意如果存在任何有条件INSTEAD规则，那么它们的反条件将被加到原始查询中。这样可能会减少它处理的行数，并且报告的状态将受影响）。
        如果有查询的任何无条件INSTEAD规则，那么原始查询将完全不被执行。在这种情况下，服务器将返回由服务器将返回由INSTEAD规则（有条件的或无条件的）插入的最后一条和原始查询命令类型（INSERT、UPDATE或DELETE）相同的查询的命令状态。如果任何规则添加的查询都不符合这些要求，那么返回的命令状态显示原始查询类型并且行计数和 OID 域为零。
    通过为任何想要的INSTEAD规则指定在活动规则中排名最后的规则名，程序员可以确保该规则都是在第二种情况里设置命令状态的规则，因为它会被最后一个应用。

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————




————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
=============规则和触发器的比较：
    在Postgresql数据库中从外部到数据的命令 “COPY FROM” 会让触发器执行，但是不会调用规则系统。
    触发器能做的在Postgresql数据库中规则系统也可以完成，使用哪种方式取决于具体的应用环境，只不过对于批量操作的场景如果使用规则，可能会生成更好的执行计划，提高效率。
    规则修改或生成额外的查询，有时让人不好理解，而触发器的方法从概念上远比规则要简单，更容易掌握。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

